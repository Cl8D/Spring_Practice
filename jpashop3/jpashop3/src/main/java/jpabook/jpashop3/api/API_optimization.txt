<정리>
1) 엔티티 직접 조회
- 엔티티를 조회해서 그대로 반환: V1
- 엔티티 조회 후 DTO로 변환: V2 (권장)
- 페치 조인으로 쿼리 수 최적화: V3
- 컬렉션 페이징과 한계 돌파: V3.1
==> 컬렉션은 페치 조인시 페이징이 불가능
==> ToOne 관계는 페치 조인으로 쿼리 수 최적화
==> 컬렉션은 페치 조인 대신에 지연 로딩을 유지하고,
hibernate.default_batch_fetch_size, @BatchSize로 최적화시키기

2) JPA에서 DTO 직접 조회
- JPA에서 DTO를 직접 조회: V4
- 컬렉션 조회 최적화
==> 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회해서 최적화: V5
==> 플랫 데이터 최적화 - JOIN 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환: V6

----

<최적화 순서>
1) 엔티티 조회 방식으로 해보기
-> 페치 조인으로 쿼리 수 최적화시키기
-> 컬렉션 최적화해주기
==> 페이징 필요함: 하이버네이트 batch_fetch_size, @BatchSize)
==> 페이징 필요x: 페치 조인

2) 1)로 해결되지 않는다면 DTO 조회 방식으로 하기
3) 2)도 안 되면 NativeSQL이나 spring JdbcTemplate 사용하기
