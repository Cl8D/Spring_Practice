@Transactional
=> 로직이 성공적으로 수행되면 커밋하도록 동작한다.
--> 테스트에서 실행하면, 테스트를 트랜잭션 안에서 실행하고, 테스트가 끝나면 트랜잭션을 자동으로 롤백시킨다!

<동작 과정> - findItems()
1) 테스트에 @Transactional이 메서드, 클래스에 있으면 트랜잭션 시작
2) 로직 실행
- 기본적으로 전파되기 때문에, 리포지토리 내에서 사용하는 JdbcTemplate도 같은 트랜잭션을 사용한다.
3) 테스트 때 insert문을 통해 item1, item2, item3 삽입 (리포지토리 호출 -> JdbcTemplate을 사용하여 저장)
4) 검증을 위해 select문으로 데이터 조회
-> 같은 트랜잭션을 사용
5) 테스트 종료 시 트랜잭션을 강제로 롤백
6) db에 insert되었던 item1, item2, item3 제거

cf) 같은 트랜잭션 사용 = 같은 커넥션 사용

- 만약, 롤백되지 않고 실제로 디비에 들어가있는 걸 보고 싶다면
@Commit을 붙이거나, @Rollback(value=false) 사용해주기!

================

<스프링 트랜잭션>
1. 클라이언트는 프록시를 호출한다
2. AOP 프록시는 스프링 컨테이너를 통해 트랜잭션 매니저를 획득한다.
3. 트랜잭션 매니저를 통해 해당하는 트랜잭션을 얻어온다 (transactionManager.getTransaction())
4. 트랜잭션 매니저는 dataSource를 통해 커넥션을 생성하고, conn.setAutoCommit(false)로 저징해준다.
5. 트랜잭션 동기화 매니저는 리포지토리에서 실질적인 데이터 접근이 발생할 때 보관되었던 트랜잭션을 꺼내오고,
실제 서비스가 호출되면 트랜잭션 동기화를 통한 커넥션을 획득해준다.

-> 개발자는 트랜잭션 처리가 필요한 곳에 @Transactional을 붙여주면 된다.
: 스프링의 트랜잭션 AOP가 해당 어노테이션을 인식하여, 트랜잭션을 처리하는 프록시를 적용해준다.
