- JDBC
: 클라이언트가 애플리케이션 서버를 통해 데이터 저장 및 조회를 할 때,

서버는 일반적으로 다음과 같은 프로세스를 진행한다.
1. TCP/IP를 사용하여 커넥션 연결
2. 애플리케이션 서버는 DB가 이해할 수 있는 SQL을 연결된 커넥션을 통해 DB에 전달
3. DB는 전달된 SQL 수행 및 결과 응답 + 서버는 응답 결과를 활용

- DB마다 다 방법이 다르니까 이를 통합하기 위해 JDBC라는 자바 표준이 등장하였다.


=======

- JDBC 표준 인터페이스
: 자바에서 DB에 접속할 수 있도록 하는 자바 API.
JDBC는 DB의 자료 쿼리 및 업데이트 방법을 제공한다.

1) 연결 - java.sql.Connection
2) SQL 담은 내용 - java.sql.Statement
3) SQL 요청 응답 - java.sql.ResultSet

- 각각의 DB는 JDBC 드라이버를 제공하여 각각의 DB에 접근할 수 있도록 한다.
(왜냐면 JDBC는 인터페이스니까, 각각을 DB에 맞춰서 구현을 해야 함)

--> 결국 개발자는 JDBC 표준 인터페이스에 맞춰서 개발을 하면 된다.
각각의 DB에 맞춰서 드라이버를 꽂아서 사용하기만 하면 되기 때문!


==============

- JDBC를 사용하는 기술 : 대표적으로 SQL Mapper / ORM 기술
SQL Mapper (JdbcTemplate / MyBatis)
: SQL 응답 결과를 객체로 변결하거나, JDBC의 반복 코드를 제거해준다.
: 그러나, SQL문 자체는 직접 작성해야 한다.

ORM 기술 (Hibernate / EclipseLink / JPA)
: 객체를 관계형 데이터베이스 테이블과 매핑해주는 기술
: 개발자가 직접 SQL을 작성할 필요 없다는 장점이 있다.


==================

- JDBC DriverManager 연결 이해
- JDBC는 java.sql.Connection이라는 표준 커넥션 인터페이스를 정의하고,
H2는 이러한 jdbc 커넥션 인터페이스의 구현체를 제공하게 된다.

- DriverManager Connection 요청 흐름
: drivermanager는 라이브러리에 등록된 db 드라이버 관리 및 커넥션 획득 기능을 제공한다.

1) 애플리케이션 로직에서 커넥션 필요 > DriverManager.getConnection() 호출
2) DriverManager는 등록된 드라이버 목록 인식 후, 커넥션 획득 가능 여부 확인
이때 URL 정보(여기에 db에 관한 직접적인 정보가 제공된다고 볼 수 있음), 접속에 필요한 정보 등을 함께 넘겨준다.
ex- URL) jdbc:h2:tcp://localhost/~...
3) 각각의 드라이버는 본인이 처리 가능한 요청인지 확인한다.
4) 찾아진 커넥션 구현체가 클라이언트에 반환된다.

===================

- 커넥션 풀의 이해
* DB의 커넥션을 획득하는 과정
1) 애플리케이션 로직이 DB 드라이버를 통해 커넥션 조회
2) DB 드라이버는 DB와 TCP/IP 커넥션 연결 (3-way handshake)
3) 연결 완료 후 ID, PW와 부가 정보를 DB에 전달
4) DB는 내부 인증 후 DB 세션 생성 - 커넥션 생성 완료 응답 전송
5) DB 드라이버는 이를 받아 커넥션 객체 생성 후 클라이언트에게 반환.

==> 응답 속도에 영향을 준다. (SQL 실행 시간 + 커넥션 만드는 시간...)
-> 한 번에 해결하기 위해 <커넥션을 미리 만들어서 사용하는> 커넥션 풀을 사용하는 것!

* 커넥션 풀
- 애플리케이션 시작 때 필요한 만큼의 커넥션을 미리 확보해서 보관해둔다 (보통 10개)
- 각각의 커넥션은 TCP/IP로 DB와 커넥션이 연결되어 있어서 언제든지 SQL를 DB에 전달 가능!

* 사용 예제 1)
- DB 드라이버가 아닌, 커넥션 풀에 있는 커넥션을 객체 참조로 가져다 쓴다.
- 커넥션 풀은 커넥션 요청을 받으면 하나를 반환한다.

* 예제 2)
- 애플리케이션 로직은 커넥션 풀에서 받은 커넥션으로 SQL을 DB에 저장하고 결과를 받아서 처리한다.
- 커넥션을 모두 사용하면 종료 대신 다시 커넥션 풀에 반환해준다. (살아있는 상태로)

- 대표적인 커넥션 풀로는 commons-dbcp2, tomcat-jdbc pool, hikariCP 등이 있다!
- 스프링은 히카리가 기본임! (대부분 히카리 사용함)


=============

- 커넥션 풀을 어떻게 하면 얻을 수 있을까?
: JDBC DriverManager 사용 or 커넥션 풀 사용

- 애플리케이션 로직에서 DriverManager를 사용해서 커넥션을 획득하다가,
HikariCP 같은 커넥션 풀을 사용하도록 변경하면 커넥션을 획득하는 코드도 같이 바꿔줘야 한다...!
-> 이를 위해 자바에서 DataSource라는 인터페이스를 제공한다.
= 이는 커넥션을 획득하는 방법을 추상화하는 인터페이스!!
--> 핵심 기능이 바로 커넥션 조회 기능!

- 커넥션 풀들은 대부분 DataSource 인터페이스를 구현해두었기 때문에,
코드에서는 DataSource 인터페이스에만 의존하도록 애플리케이션 로직을 작성하면 된다.
- 그러나, DriverManager는 DataSource 인터페이스를 사용하지 않지만,
스프링에서는 DriverMangerDataSource라는 클래스를 제공해준다.


===============

* 트랜잭션
- DB에서 트랜잭션은 하나의 거래가 안전하게 처리되도록 보장해주는 것.
DB 트랜잭션은 중간 과정 중 하나라도 실패하면 거래 전의 상태로 되돌아갈 수 있다.
- 모든 작업이 성공해서 DB 반영 = Commit / 하나라도 실패해서 이전으로 되돌리기 = Rollback


* ACID
- 원자성(A)
: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야
한다.

- 일관성(C)
: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.
ex) 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.

- 격리성(I)
: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
ex) 동시에 같은 데이터를 수정하지 못하도록!
그러나, 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.
-> 완벽하게 보장하려면 거의 순서대로 실행해야 하는데 이러면 성능이 매우 안 좋아짐.

- 지속성(D)
: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.
중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.


* 트랜잭션 격리 수준 (Isolation level)
READ UNCOMMITED(커밋되지 않은 읽기)
READ COMMITTED(커밋된 읽기) -- 기본!
REPEATABLE READ(반복 가능한 읽기)
SERIALIZABLE(직렬화 가능)


========================


* DB 연결 구조와 세션
- 사용자는 WAS나 DB 접근 툴 같은 클라이언트를 사용해서 DB 서버에 접근이 가능하다.
클라이언트는 DB 서버에 연결 요청 및 커넥션을 진행하는데, 이때 서버는 내부에 세션을 만든다
--> 해당 커넥션을 통한 모든 요청이 세션을 통해 실행된다.

- 세션은 트랜잭션 시작 및 커밋or롤백으로 종료를 한다. 이후 새로운 트랜잭션을 시작할 수 있다.
- 사용자가 커넥션을 닫거나 관리자가 세션을 강제로 종료하면 세션은 종료된다.

- 커넥션 풀이 10개의 커넥션을 생성하면, 세션 역시 개별적으로 10개가 만들어진다.


====================

* 트랜잭션 사용법
- DB 결과 반영 시 commit을, 반영 안 하고 싶으면 rollback.
- 커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것.

커밋하지 않은 데이터를 조회할 수 있다면 어떤 문제가 생길까?
-> 세션1이 커밋 안 한 데이터를 세션2가 조회하여 로직을 수행했을 때
세션1이 다시 롤백시켜버리면 데이터 정합성에 문제가 발생하게 된다.

===========

* DB의 자동 커밋과 수동 커밋.
자동 커밋)
쿼리 실행 직후에 자동으로 커밋을 호출해버려서 편리하지만, 트랜잭션 기능을 제대로 사용하기 어렵다.
set autocommit true;

수동 커밋)
set autocommit false;
수동 커밋을 설정하면 꼭 commit 및 rollback을 해줘야 한다. (안 하면 타임아웃 발생하여 자동으로 롤백)

- 참고로, 커밋 설정은 해당 세션에서 계속 유지되며, 중간에 변경도 가능하다.

cf)
오토 커밋 동작 시 계좌이체 중간에 실패가 발생하면 memberA의 돈만 빠져나가는 상황이 될 수도 있다.
그래서 이런 종류의 작업은 꼭 수동 커밋 모드로 발생해서 커밋 및 롤백을 할 수 있어야 한다!

** 보통 자동 커밋에서 수동 커밋으로 전환하는 것을 트랜잭션을 시작한다고 표현한다.

==================

* DB 락 (변경)
- 세션1이 트랜잭션을 시작하고, 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데
세션2에서 동시에 같은 데이터를 수정하면 여러 문제가 발생할 수 있기 때문에 (+여기다 세션1의 롤백까지 추가되면 대환장)
하나의 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없도록 해야 한다.
==> 락을 사용하자!

락)
- 세션 1이 트랜잭션 시작
-- memberA의 돈을 500으로 바꾸고, 해당 row의 락 획득.
-- 락을 얻었으니 update 쿼리 날리기.

- 세션 2가 트랜잭션 시작
-- memberA의 돈을 바꾸려고 하였으나, 락이 없기 때문에 락이 올 때까지 대기한다.
-- 락 대기 시간이 넘어가면 타임아웃 오류 발생.
ex) SET LOCK_TIMEOUT <milliseconds> --> 10000이 10초!

- 세션 1은 커밋을 수행한다
-- 이때, 트랜잭션이 종료되면서 락도 함께 반납된다.

- 세션 2는 대기하다가 락을 획득한다.
-- 락을 얻었으니 업데이트 쿼리를 날린다.
-- 커밋 수행 후 트랜잭션이 종료되며 락을 반납한다.


========================

* DB 락 (조회)
- 일반적인 조회에서는 락을 사용하지 않는다.
- 세션1이 락을 획득하고 데이터를 변경해도, 세션2에서 데이터 조회는 가능하다.

- 조회할 때 락을 가지고 싶다면 select for update 구문을 사용하면 된다.
ex) select * from member where member_id='memberA' for update;

-> 세션1이 조회 시점에 락을 가져가기 때문에 다른 세션에서 데이터 변경이 불가능해진다.
- 보통 memberA의 금액을 조회하고 해당 금액 정보로 어떠한 계산을 수행할 때,
이게 매우 중요한 돈 관련 계산이라면 memberA의 금액을 다른 곳에서 변경하면 안 된다.
--> 이런 경우에 보통 사용한다!


=====================

* 애플리케이션에서 트랜잭션을 거는 위치
-> 비즈니스 로직이 존재하는 서비스 계층에서 시작.
--> 비즈니스 로직이 잘못되면 문제가 되는 부분을 전부 롤백시켜야 한다.
--> 그러나, 트랜잭션을 시작하려면 커낵션이 필요하기 때문에
<서비스 계층에서 커넥션을 만들고 커밋 이후에 트랜잭션을 종료해야 한다!>
+) 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 한다! = 같은 세션을 이용하도록

** 애플리케이션에서 같은 커넥션을 유지하기 위해서는 커넥션을 파라미터로 전달한다.

=====================

*애플리케이션 구조
프레젠테이션 계층(@Controller) - 서비스 계층(@Service) - 데이터 접근 계층(@Repository) - DB 서버

프레젠) UI 처리, 웹 요청 응답, 사용자 요청 검증 / 서블릿, MVC 등 사용
서비스) 비즈니스 로직 담당, 순수 자바 코드
데이터 접근) 실제 DB에 접근 / JDBC, JPA, Redis...

- 서비스 계층은 특정 기술에 종속적이지 않아야 한다. ==> 최대한 변경없이 유지되어야 함
- 데이터 접근 계층을 직접 접근하지 않고, 인터페이스를 제공한 다음 서비스 계층이 이러한 인터페이스에 의존하는 것이 좋다.

==================

* 스프링의 트랜잭션 추상화
=> PlatformTransactionManager (트랜잭션 매니저)
(혹은 JdbcTransactionManager 사용)

getTransaction() : 트랜잭션 시작
-> 이미 진행중인 트랜잭션이 있으면, 해당 트랜잭션에 참여도 가능하다!

commit(): 트랜잭션 커밋
rollback(): 트랜잭션 롤백

=============

*트랜잭션 동기화
- 트랜잭션 매니저는 크게 2가지 역할을 수행한다
1) 트랜잭션 추상화 2) 리소스 동기화

리소스 동기화) 트랜잭션 시작과 끝까지 동일한 DB 커넥션을 유지해야 하는데,
스프링은 이를 위해 트랜잭션 동기화 매니저를 제공한다. (threadlocal을 통해 커넥션 동기화)
--> 멀티스레드에서 커넥션을 동기화할 수 있으며, 트랜잭션 동기화 매니저를 통해 커낵션을 획득하면 된다.

<동작 방식>
1) 트랜잭션 매니저는 데이터 소스를 통해 커낵션을 만들고, 트랜잭션을 시작한다.
2) 트랜잭션 시작 시 동기화 매니저에 보관한다
3) 리포지토리는 동기화 매니저에 보관된 커낵션을 꺼내서 사용한다. (파라미터로 전달할 필요 x)
4) 트랜잭션 종료 시 트랜잭션 매니저는 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 닫는다.

=========

* 트랜잭션 매니저 전체 동작 흐름
>> 클라이언트로 인해 서비스 로직 실행
1. 서비스 계층에서 transactionManager.getTransaction() 호출로 트랜잭션 시작
2. db 커넥션을 얻어오기 위해 트랜잭션 매니저는 내부에서 datasource를 사용하여 커넥션 생성
3. 커넥션을 수동 커밋 모드로 변경하여, 실제 데이터베이스 트랜잭션 시작
4. 커넥션을 트랜잭션 동기화 매니저에 보관
5. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관함 -> 멀티 쓰레드 환경이라도 안전
6. 서비스는 비즈니스 로직 실행 (커넥션을 넘기지 않음!)
7. 로직에 있는 메서드들은 커넥션을 가져오기 위해서 DataSourceUtils.getConnection()을 통해 가져옴 -> 트랜잭션 유지
8. 획득한 커낵션으로 SQL을 db에 전달 후 실행
9. 로직 종료 후 트랜잭션 종료 시도 (커밋 or 롤백)
10. 이때, 동기화된 커넥션을 가져오기 위해 트랜잭션 동기화 매니저를 통해 동기화됙 커넥션을 획득함.
11. 가져온 커넥션으로 트랜잭션 종료
12. 리소스 정리
-> 트랜잭션 동기화 매니저 정리 / setAutoCommit(true) / 커넥션 종료 (커넥션 풀에 반환됨)

===============

* 템플릿 콜백 패턴
-> 트랜잭션의 커밋, 롤백 코드가 서비스에서 변경되니까 공통적인 걸 만들자는 것!
스프링에서는 TransactionTemplate을 제공한다.
execute(): 응답값이 있을 때 사용
executeWithoutResult(): 응답값이 없을 때 사용!

==================

* 서비스 계층에 순수한 비즈니스 로직만 남기려면 어떻게 해야 할까? (현재는 트랜잭션 코드도 있음)
-> 스프링 AOP를 활용하여 프록시를 도입해보자.

- 프록시를 도입하기 전에는 서비스 로직에서 트랜잭션을 직접 시작하지만,
프록시를 사용하면 트랜잭션을 처리하는 객체와 비즈니스를 로직을 처리하는 서비스 객체를 분리할 수 있다!
==> 트랜잭션 프록시가 트랜잭션 처리 로직을 가져가고, 트랜잭션 시작 시 실제 서비스를 대신 호출해줌!
==> @Transactional을 이용하자!
(원래 스프링 AOP를 사용하려면 @Aspect, @advice, @Pointcut이 필요한데, 스프링 부트를 이용하면 이러한 빈들을 자동으로 등록해줌!)

- @Transactional을 사용해서 트랜잭션 적용하는 것이 '선언적 트랜잭션 관리' => 대부분 실무에서 사용!
- 트랜잭션 매니저나 트랜잭션 템플릿을 사용해서 직접 트랜잭션 코드를 작성하는 것이 프로그래밍 방식의 트랜잭션 관리이다.

- 스프링부트는 dataSource를 스프링 빈에 자동으로 등록한다...!
=> 이때, application.properties에 있는 속성을 사용해서 dataSource를 생성해준다! => 없으면 내장 메모리 사용
-> 스프링부트는 기본적으로 HikariDataSource를 사용한다.

- 마찬가지로 트랜잭션 매니저도 자동으로 등록해주는데, 등록된 라이브러리를 보고 판단하여 등록해준다!
