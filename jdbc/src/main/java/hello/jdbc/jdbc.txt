- JDBC
: 클라이언트가 애플리케이션 서버를 통해 데이터 저장 및 조회를 할 때,

서버는 일반적으로 다음과 같은 프로세스를 진행한다.
1. TCP/IP를 사용하여 커넥션 연결
2. 애플리케이션 서버는 DB가 이해할 수 있는 SQL을 연결된 커넥션을 통해 DB에 전달
3. DB는 전달된 SQL 수행 및 결과 응답 + 서버는 응답 결과를 활용

- DB마다 다 방법이 다르니까 이를 통합하기 위해 JDBC라는 자바 표준이 등장하였다.


=======

- JDBC 표준 인터페이스
: 자바에서 DB에 접속할 수 있도록 하는 자바 API.
JDBC는 DB의 자료 쿼리 및 업데이트 방법을 제공한다.

1) 연결 - java.sql.Connection
2) SQL 담은 내용 - java.sql.Statement
3) SQL 요청 응답 - java.sql.ResultSet

- 각각의 DB는 JDBC 드라이버를 제공하여 각각의 DB에 접근할 수 있도록 한다.
(왜냐면 JDBC는 인터페이스니까, 각각을 DB에 맞춰서 구현을 해야 함)

--> 결국 개발자는 JDBC 표준 인터페이스에 맞춰서 개발을 하면 된다.
각각의 DB에 맞춰서 드라이버를 꽂아서 사용하기만 하면 되기 때문!


==============

- JDBC를 사용하는 기술 : 대표적으로 SQL Mapper / ORM 기술
SQL Mapper (JdbcTemplate / MyBatis)
: SQL 응답 결과를 객체로 변결하거나, JDBC의 반복 코드를 제거해준다.
: 그러나, SQL문 자체는 직접 작성해야 한다.

ORM 기술 (Hibernate / EclipseLink / JPA)
: 객체를 관계형 데이터베이스 테이블과 매핑해주는 기술
: 개발자가 직접 SQL을 작성할 필요 없다는 장점이 있다.


==================

- JDBC DriverManager 연결 이해
- JDBC는 java.sql.Connection이라는 표준 커넥션 인터페이스를 정의하고,
H2는 이러한 jdbc 커넥션 인터페이스의 구현체를 제공하게 된다.

- DriverManager Connection 요청 흐름
: drivermanager는 라이브러리에 등록된 db 드라이버 관리 및 커넥션 획득 기능을 제공한다.

1) 애플리케이션 로직에서 커넥션 필요 > DriverManager.getConnection() 호출
2) DriverManager는 등록된 드라이버 목록 인식 후, 커넥션 획득 가능 여부 확인
이때 URL 정보(여기에 db에 관한 직접적인 정보가 제공된다고 볼 수 있음), 접속에 필요한 정보 등을 함께 넘겨준다.
ex- URL) jdbc:h2:tcp://localhost/~...
3) 각각의 드라이버는 본인이 처리 가능한 요청인지 확인한다.
4) 찾아진 커넥션 구현체가 클라이언트에 반환된다.

===================

- 커넥션 풀의 이해
* DB의 커넥션을 획득하는 과정
1) 애플리케이션 로직이 DB 드라이버를 통해 커넥션 조회
2) DB 드라이버는 DB와 TCP/IP 커넥션 연결 (3-way handshake)
3) 연결 완료 후 ID, PW와 부가 정보를 DB에 전달
4) DB는 내부 인증 후 DB 세션 생성 - 커넥션 생성 완료 응답 전송
5) DB 드라이버는 이를 받아 커넥션 객체 생성 후 클라이언트에게 반환.

==> 응답 속도에 영향을 준다. (SQL 실행 시간 + 커넥션 만드는 시간...)
-> 한 번에 해결하기 위해 <커넥션을 미리 만들어서 사용하는> 커넥션 풀을 사용하는 것!

* 커넥션 풀
- 애플리케이션 시작 때 필요한 만큼의 커넥션을 미리 확보해서 보관해둔다 (보통 10개)
- 각각의 커넥션은 TCP/IP로 DB와 커넥션이 연결되어 있어서 언제든지 SQL를 DB에 전달 가능!

* 사용 예제 1)
- DB 드라이버가 아닌, 커넥션 풀에 있는 커넥션을 객체 참조로 가져다 쓴다.
- 커넥션 풀은 커넥션 요청을 받으면 하나를 반환한다.

* 예제 2)
- 애플리케이션 로직은 커넥션 풀에서 받은 커넥션으로 SQL을 DB에 저장하고 결과를 받아서 처리한다.
- 커넥션을 모두 사용하면 종료 대신 다시 커넥션 풀에 반환해준다. (살아있는 상태로)

- 대표적인 커넥션 풀로는 commons-dbcp2, tomcat-jdbc pool, hikariCP 등이 있다!
- 스프링은 히카리가 기본임! (대부분 히카리 사용함)


=============

- 커넥션 풀을 어떻게 하면 얻을 수 있을까?
: JDBC DriverManager 사용 or 커넥션 풀 사용

- 애플리케이션 로직에서 DriverManager를 사용해서 커넥션을 획득하다가,
HikariCP 같은 커넥션 풀을 사용하도록 변경하면 커넥션을 획득하는 코드도 같이 바꿔줘야 한다...!
-> 이를 위해 자바에서 DataSource라는 인터페이스를 제공한다.
= 이는 커넥션을 획득하는 방법을 추상화하는 인터페이스!!
--> 핵심 기능이 바로 커넥션 조회 기능!

- 커넥션 풀들은 대부분 DataSource 인터페이스를 구현해두었기 때문에,
코드에서는 DataSource 인터페이스에만 의존하도록 애플리케이션 로직을 작성하면 된다.
- 그러나, DriverManager는 DataSource 인터페이스를 사용하지 않지만,
스프링에서는 DriverMangerDataSource라는 클래스를 제공해준다.


===============

* 트랜잭션
- DB에서 트랜잭션은 하나의 거래가 안전하게 처리되도록 보장해주는 것.
DB 트랜잭션은 중간 과정 중 하나라도 실패하면 거래 전의 상태로 되돌아갈 수 있다.
- 모든 작업이 성공해서 DB 반영 = Commit / 하나라도 실패해서 이전으로 되돌리기 = Rollback


* ACID
- 원자성(A)
: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야
한다.

- 일관성(C)
: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.
ex) 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.

- 격리성(I)
: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
ex) 동시에 같은 데이터를 수정하지 못하도록!
그러나, 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.
-> 완벽하게 보장하려면 거의 순서대로 실행해야 하는데 이러면 성능이 매우 안 좋아짐.

- 지속성(D)
: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.
중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.


* 트랜잭션 격리 수준 (Isolation level)
READ UNCOMMITED(커밋되지 않은 읽기)
READ COMMITTED(커밋된 읽기) -- 기본!
REPEATABLE READ(반복 가능한 읽기)
SERIALIZABLE(직렬화 가능)


========================


* DB 연결 구조와 세션
- 사용자는 WAS나 DB 접근 툴 같은 클라이언트를 사용해서 DB 서버에 접근이 가능하다.
클라이언트는 DB 서버에 연결 요청 및 커넥션을 진행하는데, 이때 서버는 내부에 세션을 만든다
--> 해당 커넥션을 통한 모든 요청이 세션을 통해 실행된다.

- 세션은 트랜잭션 시작 및 커밋or롤백으로 종료를 한다. 이후 새로운 트랜잭션을 시작할 수 있다.
- 사용자가 커넥션을 닫거나 관리자가 세션을 강제로 종료하면 세션은 종료된다.

- 커넥션 풀이 10개의 커넥션을 생성하면, 세션 역시 개별적으로 10개가 만들어진다.


====================

* 트랜잭션 사용법
- DB 결과 반영 시 commit을, 반영 안 하고 싶으면 rollback.
- 커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것.

커밋하지 않은 데이터를 조회할 수 있다면 어떤 문제가 생길까?
-> 세션1이 커밋 안 한 데이터를 세션2가 조회하여 로직을 수행했을 때
세션1이 다시 롤백시켜버리면 데이터 정합성에 문제가 발생하게 된다.

===========

* DB의 자동 커밋과 수동 커밋.
자동 커밋)
쿼리 실행 직후에 자동으로 커밋을 호출해버려서 편리하지만, 트랜잭션 기능을 제대로 사용하기 어렵다.
set autocommit true;

수동 커밋)
set autocommit false;
수동 커밋을 설정하면 꼭 commit 및 rollback을 해줘야 한다. (안 하면 타임아웃 발생하여 자동으로 롤백)

- 참고로, 커밋 설정은 해당 세션에서 계속 유지되며, 중간에 변경도 가능하다.

cf)
오토 커밋 동작 시 계좌이체 중간에 실패가 발생하면 memberA의 돈만 빠져나가는 상황이 될 수도 있다.
그래서 이런 종류의 작업은 꼭 수동 커밋 모드로 발생해서 커밋 및 롤백을 할 수 있어야 한다!

** 보통 자동 커밋에서 수동 커밋으로 전환하는 것을 트랜잭션을 시작한다고 표현한다.

==================

* DB 락 (변경)
- 세션1이 트랜잭션을 시작하고, 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데
세션2에서 동시에 같은 데이터를 수정하면 여러 문제가 발생할 수 있기 때문에 (+여기다 세션1의 롤백까지 추가되면 대환장)
하나의 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없도록 해야 한다.
==> 락을 사용하자!

락)
- 세션 1이 트랜잭션 시작
-- memberA의 돈을 500으로 바꾸고, 해당 row의 락 획득.
-- 락을 얻었으니 update 쿼리 날리기.

- 세션 2가 트랜잭션 시작
-- memberA의 돈을 바꾸려고 하였으나, 락이 없기 때문에 락이 올 때까지 대기한다.
-- 락 대기 시간이 넘어가면 타임아웃 오류 발생.
ex) SET LOCK_TIMEOUT <milliseconds> --> 10000이 10초!

- 세션 1은 커밋을 수행한다
-- 이때, 트랜잭션이 종료되면서 락도 함께 반납된다.

- 세션 2는 대기하다가 락을 획득한다.
-- 락을 얻었으니 업데이트 쿼리를 날린다.
-- 커밋 수행 후 트랜잭션이 종료되며 락을 반납한다.


========================

* DB 락 (조회)
- 일반적인 조회에서는 락을 사용하지 않는다.
- 세션1이 락을 획득하고 데이터를 변경해도, 세션2에서 데이터 조회는 가능하다.

- 조회할 때 락을 가지고 싶다면 select for update 구문을 사용하면 된다.
ex) select * from member where member_id='memberA' for update;

-> 세션1이 조회 시점에 락을 가져가기 때문에 다른 세션에서 데이터 변경이 불가능해진다.
- 보통 memberA의 금액을 조회하고 해당 금액 정보로 어떠한 계산을 수행할 때,
이게 매우 중요한 돈 관련 계산이라면 memberA의 금액을 다른 곳에서 변경하면 안 된다.
--> 이런 경우에 보통 사용한다!


=====================

* 애플리케이션에서 트랜잭션을 거는 위치
-> 비즈니스 로직이 존재하는 서비스 계층에서 시작.
--> 비즈니스 로직이 잘못되면 문제가 되는 부분을 전부 롤백시켜야 한다.
--> 그러나, 트랜잭션을 시작하려면 커낵션이 필요하기 때문에
<서비스 계층에서 커넥션을 만들고 커밋 이후에 트랜잭션을 종료해야 한다!>
+) 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 한다! = 같은 세션을 이용하도록

** 애플리케이션에서 같은 커넥션을 유지하기 위해서는 커넥션을 파라미터로 전달한다.


