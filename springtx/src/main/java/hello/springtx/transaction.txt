@Transactional에서 트랜잭션 프록시가 사용할 트랜잭션 매니저를 지정해줘야 한다.
-> 생략하면 기본으로 등록된 트랜잭션 매니저를 사용한다.

만약 원하는 트랜잭션 매니저가 둘 이상이면
@Transactional("memberTxManager")
 public void member() {...}

@Transactional("orderTxManager")
 public void order() {...}

 이런 식으로 value 값에 넣어주게 된다.

 ==================

* 예외 처리
- 언체크 예외: RuntimeException, Error, 하위 예외는 롤백
- 체크 예외: Exception, 하위 예외는 커밋.
: 활용하기
체크 -> 비즈니스 예외가 있을 때 사용하기 (시스템 문제가 아니라, 비즈니스상에서 예외가 발생할 경우 ex. 고객의 잔고 부족)
언체크 -> 복구 불가능한 예외

추가적으로 롤백할 예외를 커스텀하고 싶다면
@Transactional(rollbackFor=Exception.class) 이런 식으로 지정해주면 된다.
(참고로, 지정한 예외와 하위 예외들이 모두 포함된다)

반대로 롤백을 안 하게 하고 싶다면 noRollbackFor 옵션을 사용한다.

- isolation으로 격리 수준을 지정할 수도 있지만, 보통은 db에서 설정한 격리 수준을 따른다.

=========

* readOnly
- 읽기 전용 트랜잭션의 생성 / 근데 드라이버랑 DB에 따라서 동작 안 할 수도 있삼

- JdbcTemplate은 읽기 전용 트랜잭션 안에서 변경 기능을 실행하면 예외를 던진다.
- JPA는 커밋 시점에 플러시를 호출하지 않는다. (변경 감지를 위한 스냅샷도 만들지 않는다.)
- JDBC 드라이버는 변경 쿼리 발생 시 예외를 던진다 (근데 버전 따라서 다름)
