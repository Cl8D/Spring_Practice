@Transactional에서 트랜잭션 프록시가 사용할 트랜잭션 매니저를 지정해줘야 한다.
-> 생략하면 기본으로 등록된 트랜잭션 매니저를 사용한다.

만약 원하는 트랜잭션 매니저가 둘 이상이면
@Transactional("memberTxManager")
 public void member() {...}

@Transactional("orderTxManager")
 public void order() {...}

 이런 식으로 value 값에 넣어주게 된다.

 ==================

* 예외 처리
- 언체크 예외: RuntimeException, Error, 하위 예외는 롤백
- 체크 예외: Exception, 하위 예외는 커밋.
: 활용하기
체크 -> 비즈니스 예외가 있을 때 사용하기 (시스템 문제가 아니라, 비즈니스상에서 예외가 발생할 경우 ex. 고객의 잔고 부족)
언체크 -> 복구 불가능한 예외

추가적으로 롤백할 예외를 커스텀하고 싶다면
@Transactional(rollbackFor=Exception.class) 이런 식으로 지정해주면 된다.
(참고로, 지정한 예외와 하위 예외들이 모두 포함된다)

반대로 롤백을 안 하게 하고 싶다면 noRollbackFor 옵션을 사용한다.

- isolation으로 격리 수준을 지정할 수도 있지만, 보통은 db에서 설정한 격리 수준을 따른다.

=========

* readOnly
- 읽기 전용 트랜잭션의 생성 / 근데 드라이버랑 DB에 따라서 동작 안 할 수도 있삼

- JdbcTemplate은 읽기 전용 트랜잭션 안에서 변경 기능을 실행하면 예외를 던진다.
- JPA는 커밋 시점에 플러시를 호출하지 않는다. (변경 감지를 위한 스냅샷도 만들지 않는다.)
- JDBC 드라이버는 변경 쿼리 발생 시 예외를 던진다 (근데 버전 따라서 다름)


====================

* 트랜잭션 전파
- 이미 트랜잭션이 진행 중일 때 추가로 트랜잭션을 수행한다면?
==> 트랜잭션 전파. 기본 옵션은 required.

1) 외부 트랜잭션 수행 - 내부 트랜잭션 추가 수행
: 둘을 묶어서 하나의 트랜잭션에서 동작 (내부에 있던 애가 외부의 트랜잭션에 참여)

'논리 트랜잭션'은 하나의 '물리 트랜잭션'으로 묶인다. (여러 개의 트랜잭션을 묶는 하나의 물리 트랜잭션!)
-> 실제 db에 적용되는 트랜잭션이 물리 트랜잭션이며,
커넥션을 통해서 트랜잭션을 시작하고(setAutoCommit(false)), 실제 커넥션을 통해서 커밋, 롤백하는 단위

- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.
- 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백한다.

---

[내부 커밋 - 외부 커밋]
<외부 트랜잭션 요청 흐름>
1. getTransaction()으로 외부 트랜잭션 시작
2. 트랜잭션 매니저는 dataSource를 통해 커넥션 생성
3. 생성한 커넥션에 대해 setAutoCommit(false) - 물리 트랜잭션의 시작!
4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션 보관
5. 트랜잭션 매니저는 트랜잭션 생성 결과를 TransactionStatus에 담아서 반환 (신규 트랜잭션 여부 - isNewTransaction 존재)
6. 추후 로직 실행 시 커넥션 필요한 경우 동기화 매니저를 통해 트랜잭션 적용된 커넥션을 획득해서 사용
7. 로직 종료 후 트랜잭션 매니저를 통해 외부 트랜잭션 커밋
8. '신규 트랜잭션'이기 때문에 DB 커넥션에 실제 커밋을 호출한다.
- 이때, 논리적인 커밋이라면 이런 실제 커밋이 물리 커밋이 되며, 실제 DB에 반영되고 물리 트랜잭션 종료

<내부 트랜잭션 요청 흐름>
1. getTransaction()을 호출해서 내부 트랜잭션 시작
2. 트랜잭션 매니저는 동기화 매니저를 통해 기존 트랜잭션 존재 여부 확인
- 있으면 참여(아무것도 안 함) : 동기화 매니저에 보관된 커넥션을 사용하는 것
3. 마찬가지로 생성 결과를 TransactionStatus에 담아서 보관
4. 6번이랑 동일.
5. 로직 종료 후 트랜잭션 매니저를 통해 내부 트랜잭션 커밋
6. 그러나, 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않음. (외부까지 이어져야 하니까...)

---

[내부 커밋 - 외부 롤백]
- 트랜잭션 시작 부분 제외

<내부 트랜잭션>
1. 로직 종료 후 트랜잭션 매니저를 통해 내부 트랜잭션 커밋
2. 신규 트랜잭션이 아니니까 실제 커밋 호출 x

<외부 트랜잭션>
1. 로직 종료 후 트랜잭션 매니저를 통해 외부 트랜잭션 롤백
2. 신규 트랜잭션이니까 db 커넥션에 실제 롤백 호출
= 논리적인 롤백이기 때문에 실제 커넥션에 롤백하는 것이 물리 롤백이 된다.
= 실제 DB에 롤백 반영 후 물리 트랜잭션 종료

---

[내부 롤백 - 외부 커밋]
<내부 트랜잭션>
1. 로직 종료 후 트랜잭션 매니저를 통해 내부 트랜잭션 롤백
2. 신규 트랜잭션이 아니니까 실제 롤백은 호출 x
3. 대신, 트랜잭션 동기화 매니저에 rollbackOnly=true 표시를 해둔다

<외부 트랜잭션>
1. 로직 종료 후 트랜잭션 매니저를 통해 외부 트랜잭션 커밋
2. 신규 트랜잭션이니까 DB 커넥션에 실제 커밋을 호출하는데, 이때 롤백 전용 표시가 있으면 커밋 대신 롤백한다.
3. 실제 DB에 롤백 반영 후 물리 트랜잭션 종료
4. 스프링은 이때 UnexpectedRollbackException (런타임 예외)를 발생시킨다.

============

[내부-외부 분리: requires_new]
<외부>
1. 트랜잭션 시작 (과정 생략) 후 로직 시 필요하면 커넥션 획득하여 사용
2. 커밋 시점에 신규 트랜잭션임을 판단하고 rollbackOnly 설정 체크. 아니니까 conn1로 커밋. 종료 후 풀에 반납

<내부>
1. 내부 트랜잭션 시작
-> 이때, 트랜잭션 매니저는 requires_new 옵션을 확인하고 새로운 트랜잭션 시작
: 이후 과정을 똑같음
: 참고로, 외부에서 만들어졌던 conn0은 보류 상태고 내부 트랜잭션을 완료할 때까지 conn1 사용
2. 롤백 시점에 신규 트랜잭션이기 때문에 실제 롤백 호출
-> conn1 롤백, 종료 후 커넥션 풀에 반납
-> 이러면 conn0의 보류 상태가 끝나고 다시 사용!


